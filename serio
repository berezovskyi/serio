#!/usr/bin/env python
# Small utility to upload/downlaod files to an embedded Linux system via a serial port shell.

import serial
import sys, os.path, time
from getopt import GetoptError, getopt as GetOpt

class ParseMinicom:

	PATH = "/etc/minicom/"
	PREFIX = "minirc."
	CONF = {'baudrate' : None, 'port' : None}

	def __init__(self, name):
		path = self.PATH + self.PREFIX + name
		
		for line in open(path).readlines():
			for key,value in self.CONF.iteritems():
				if line.startswith('pu ' + key):
					self.CONF[key] = line.split(key)[1].strip()

	def setting(self, name):
		if self.CONF.has_key(name):
			return self.CONF[name]
		else:
			return None

	def baudrate(self):
		return self.setting('baudrate')

	def port(self):
		return self.setting('port')

class SerialCP:

	DELIM="THIS IS THE END, BEAUTIFUL FRIEND"

	def __init__(self, port=None, baudrate=None, callback=None):
		self.callback = callback

		self.serial = serial.Serial(port=port, baudrate=baudrate)
		self.serial.open()

	def cmd(self, command):
		self.serial.write(command + "\n")
		self.serial.readline()

	def readuntil(self, delim=DELIM):
		data = ""

		while not data.endswith(delim):
			data += self.serial.read(1)
			if self.callback is not None:
				self.callback(len(data), len(data))

		return data[0:-len(delim)]

	def get(self, remote, local):
		retval = 0

		self.cmd("cat '%s' && echo '%s'" % (remote, self.DELIM))
		data = self.readuntil(self.DELIM)

		# Catting data over the serial port turns all \n's to \r\n's
		data = data.replace("\r\n", "\n")

		if local and local is not None:
			try:
				open(local, 'wb').write(data)
				retval = len(data)
			except:
				pass
		return retval

	def close(self):
		self.serial.close()


class SerialFTP:

	IO_TIME = .1
	BYTES_PER_LINE = 20

	def __init__(self, port=None, baudrate=None, time=None, callback=None):
		self.callback = callback
		if time is not None:
			self.IO_TIME = time
		self.s = serial.Serial(port=port, baudrate=baudrate)
		self.s.open()

	def put(self, source, destination):
		data = open(source).read()
		data_size = len(data)
		i = 0
		j = 0

		# Create/zero the file
		self.write('\necho -ne > %s\n' % destination)
		
		# Loop through all the bytes in the source file and append them to
		# the destination file BYTES_PER_LINE bytes at a time
		while i < data_size:
			j = 0
			dpart = ''

			while j < self.BYTES_PER_LINE and i < data_size:
				dpart += '\\x%.2X' % int(ord(data[i]))
				j+=1
				i+=1
				
			self.write('\necho -ne "%s" >> %s\n' % (dpart, destination))

			# Show upload status
			if self.callback is not None:
				self.callback(i, data_size)

		return i

	def write(self, data):
		self.s.write(data)
		if data.endswith('\n'):
			# Have to give the target system time for disk/flash I/O
			time.sleep(self.IO_TIME)

	def close(self):
		self.s.close()





def progress(self, current, total):
	if current > total:
		current = total

	percent = (current / float(total)) * 100
	marks = int(math.floor(percent / 2))
	markstring = "#" * marks
	dotstring = "." * (50 - marks)
	sys.stdout.write("\r[%s%s] %0.2f%% (%d / %d)" % (markstring, dotstring, percent, current, total))
	sys.stdout.flush()

def usage():
	print '\nUsage: %s [OPTIONS]\n' % sys.argv[0]
	print '\t-g, --get                              Get a file from the remote system'
	print '\t-p, --put                              Put a file to the remote system'
	print '\t-s, --source=<local file>              Path to local file'
	print '\t-d, --destination=<remote file>        Path to remote file'
	print '\t-m, --minicom=<name>                   Name of a minicom config file'
	print '\t-y, --port=<serial port>               Serial port to use [/dev/ttyUSB0]'
	print '\t-b, --baudrate=<baud>                  Serial port baud rate [115200]'
	print '\t-t, --time=<seconds>                   Time to wait between echo commands [0.1]'
	print '\t-h, --help                             Show help'
	print ''
	sys.exit(1)

def main():

	port = '/dev/ttyUSB0'
	baudrate = 115200
	time = None
	source = None
	action = None
	minicom = None
	destination = None

	try:
		opts, args = GetOpt(sys.argv[1:],'y:b:s:d:t:m:gph', ['port=', 'baudrate=', 'source=', 'destination=', 'time=', 'minicom', 'get', 'put', 'help'])
	except GetoptError, e:
		print 'Usage error:', e
		usage()

	for opt, arg in opts:
		if opt in ('-y', '--port'):
			port = arg
		elif opt in ('-b', '--baudrate'):
			baudrate = arg
		elif opt in ('-s', '--source'):
			source = arg
		elif opt in ('-d', '--destination'):
			destination = arg
		elif opt in ('-t', '--time'):
			time = arg
		elif opt in ('-m', '--minicom'):
			minicom = ParseMinicom(arg)
		elif opt in ('-p', '--put'):
			action = 'put'
		elif opt in ('-g', '--get'):
			action = 'get'
		elif opt in ('-h', '--help'):
			usage()

	if action is None:
		print 'Usage error: must specify either -g or -p options'
		usage()

	if not source or not destination:
		print 'Usage error: must specify -s and -d options'
		usage()

	if minicom is not None:
		port = minicom.port()
		baudrate = minicom.baudrate()

	if action == 'put':
		try:
			sftp = SerialFTP(port=port, baudrate=baudrate, time=time, callback=progress)
			size = sftp.put(source, destination)
			sftp.close()
		
			print 'Uploaded %d bytes from %s to %s' % (size, source, destination)
		except Exception, e:
			print "ERROR:", e
	else:
		try:
			scp = SerialCP(port=port, baudrate=baudrate, callback=progress)
			size = scp.get(source, destination)
			scp.close()

			print 'Downloaded %d bytes from %s to %s' % (size, source, destination)
		except Exception, e:
			print "ERROR:", e



if __name__ == '__main__':
	main()
